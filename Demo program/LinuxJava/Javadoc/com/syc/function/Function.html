<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="zh">
<head>
<!-- Generated by javadoc (version 1.7.0_03) on Fri Oct 26 13:40:17 CST 2012 -->
<title>Function</title>
<meta name="date" content="2012-10-26">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Function";
    }
//-->
</script>
<noscript>
<div>您的浏览器已禁用 JavaScript。</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="跳过导航链接"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../com/syc/function/package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/Function.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../index-files/index-1.html">索引</a></li>
<li><a href="../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>上一个类</li>
<li>下一个类</li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?com/syc/function/Function.html" target="_top">框架</a></li>
<li><a href="Function.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li>嵌套&nbsp;|&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">方法</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">com.syc.function</div>
<h2 title="类 Function" class="title">类 Function</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>com.syc.function.Function</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">Function</span>
extends java.lang.Object</pre>
<div class="block">RFID读卡器USB接口，Linux下的Java接口类。使用该包时，请将Function.jar,jNative.jar,libfunction.so,libJNativeCpp.so复制到工程目录下。导入 Function.jar,jNative.jar接口包。<br/> <br/>
<b>函数返回值代码表：</b><br/>
0x00 命令执行成功  <br/>
0x01 命令操作失败（失败原因请参考底层单片机上传代码表）<br/>
0x02 地址校验错误<br/>
0x03 没有选择COM口<br/>
0x04 读写器返回超时<br/>
0x05 数据包流水号不正确 <br/>
0x07 接收异常<br/>
0x0A  参数值超出范围 <br/> <br/>
<b>底层单片机上传代码表：</b><br/>
0x80 参数设置成功<br/>
0x81 参数设置失败<br/>
0x82 通讯超时 <br/>
0x83 卡不存在<br/>
0x84 接收卡数据出错<br/>
0x87 未知的错误<br/>
0x85 输入参数或者输入命令格式错误<br/>
0x8f 输入的指令代码不存在<br/>
0x8A 在对于卡块初始化命令中出现错误（仅用于14443命令）<br/>
0x8B 在防冲突过程中得到错误的序列号（仅用于14443命令）<br/>
0x8C 密码认证没通过（仅用于14443命令）<br/>
0x90 卡不支持这个命令（仅用于15693命令）<br/>
0x91 命令格式有错误（仅用于15693命令）<br/>
0x92 在命令的FLAG参数中，不支持OPTION 模式（仅用于15693命令）<br/>
0x93 要操作的BLOCK不存在（仅用于15693命令）<br/>
0x94 要操作的对象已经别锁定，不能进行修改（仅用于15693命令）<br/>
0x95 锁定操作不成功（仅用于15693命令）<br/>
0x96 写操作不成功（仅用于15693命令）<br/></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>构造器概要</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="构造器概要表, 列表构造器和解释">
<caption><span>构造器</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">构造器和说明</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../../com/syc/function/Function.html#Function()">Function</a></strong>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>方法概要</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="方法概要表, 列表方法和解释">
<caption><span>方法</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">限定符和类型</th>
<th class="colLast" scope="col">方法和说明</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#AntiType_B(byte[])">AntiType_B</a></strong>(byte[]&nbsp;buffer)</code>
<div class="block">ISO14443B命令：该命令执行ISO14443B中的AnticollB命令.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_ControlBuzzer(byte, byte, byte[])">API_ControlBuzzer</a></strong>(byte&nbsp;freq,
                 byte&nbsp;duration,
                 byte[]&nbsp;buffer)</code>
<div class="block">系统命令：设置蜂鸣器的工作状态，包括，蜂鸣器的工作周期以及循环的次数。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_ControlLED(byte, byte, byte[])">API_ControlLED</a></strong>(byte&nbsp;freq,
              byte&nbsp;duration,
              byte[]&nbsp;buffer)</code>
<div class="block">系统命令：设置灯的工作状态，包括，灯亮的周期以及循环的次数。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_GetSerNum(byte[])">API_GetSerNum</a></strong>(byte[]&nbsp;buffer)</code>
<div class="block">系统命令：读取由厂家预设的1个字节的读卡器地址和8个字节序列号。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_ISO14443TypeBTransCOSCmd(byte[], int, byte[])">API_ISO14443TypeBTransCOSCmd</a></strong>(byte[]&nbsp;cmd,
                            int&nbsp;cmdSize,
                            byte[]&nbsp;buffer)</code>
<div class="block">ISO14443B命令：ISO14443传送命令，可以通过此命令向卡发任意有效的命令，数据.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_ISO15693_GetMulSecurity(byte, byte, byte, byte[], byte[])">API_ISO15693_GetMulSecurity</a></strong>(byte&nbsp;flags,
                           byte&nbsp;blkAddr,
                           byte&nbsp;blkNum,
                           byte[]&nbsp;uid,
                           byte[]&nbsp;pBuffer)</code>
<div class="block">ISO15693命令：用于获取卡的各个块的安全状态位的数据</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_ISO15693_GetSysInfo(byte, byte[], byte[])">API_ISO15693_GetSysInfo</a></strong>(byte&nbsp;flags,
                       byte[]&nbsp;uid,
                       byte[]&nbsp;buffer)</code>
<div class="block">ISO15693命令：用于得到卡的详细信息，具体内容请参考，ISO15693协议资料。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_ISO15693_Inventory(byte, byte, byte[], byte[], byte[])">API_ISO15693_Inventory</a></strong>(byte&nbsp;flag,
                      byte&nbsp;afi,
                      byte[]&nbsp;pData,
                      byte[]&nbsp;nrOfCard,
                      byte[]&nbsp;pBuffer)</code>
<div class="block">ISO15693命令：此命令通过防冲突用于得到读卡区域内所有卡片的序列号（能得到的卡片数量与模块天线的输出功率有关，一般能对2~6卡进行防冲突）.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_ISO15693Lock(byte, byte, byte[], byte[])">API_ISO15693Lock</a></strong>(byte&nbsp;flags,
                byte&nbsp;num_blk,
                byte[]&nbsp;uid,
                byte[]&nbsp;buffer)</code>
<div class="block">ISO15693命令：用于锁定块内容。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_ISO15693Read(byte, byte, byte, byte[], byte[])">API_ISO15693Read</a></strong>(byte&nbsp;flags,
                byte&nbsp;blk_add,
                byte&nbsp;num_blk,
                byte[]&nbsp;uid,
                byte[]&nbsp;buffer)</code>
<div class="block">ISO15693命令：用来读取1个或多个扇区的值，如果要读每个块的安全位，将FLAGS中Option_flag置为1，即FLAG = 0X42，每个扇区将返回5个字节，包括1个表示安全状态字节和4个字节的块内容，这时候每次最多能读12个块。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_ISO15693Select(byte, byte[], byte[])">API_ISO15693Select</a></strong>(byte&nbsp;flags,
                  byte[]&nbsp;uid,
                  byte[]&nbsp;buffer)</code>
<div class="block">ISO15693命令：此命令必须用地址模式，如果发送的数据与被操作的卡的序列号相同，操作成功后，卡将进入被选择状态，否则状态不变。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_ISO15693StayQuiet(byte, byte[], byte[])">API_ISO15693StayQuiet</a></strong>(byte&nbsp;flags,
                     byte[]&nbsp;uid,
                     byte[]&nbsp;buffer)</code>
<div class="block">ISO15693命令：此命令用于将卡置于静止的状态, 必须用地址模式，如果发送的数据与被操作的卡的序列号相同，操作成功后，卡将进入静止状态，否则状态不变。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_ISO15693TransCOSCmd(byte[], int, byte[])">API_ISO15693TransCOSCmd</a></strong>(byte[]&nbsp;cmd,
                       int&nbsp;cmdSize,
                       byte[]&nbsp;buffer)</code>
<div class="block">ISO15693命令：一个通用命令，用户可以通过此命令，对卡进行各种操作。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_ISO15693Write(byte, byte, byte, byte[], byte[])">API_ISO15693Write</a></strong>(byte&nbsp;flags,
                 byte&nbsp;blk_add,
                 byte&nbsp;num_blk,
                 byte[]&nbsp;uid,
                 byte[]&nbsp;data)</code>
<div class="block">ISO15693命令：对一个块进行写操作（每次只能写一个块）。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_LockAFI(byte, byte[], byte[])">API_LockAFI</a></strong>(byte&nbsp;flags,
           byte[]&nbsp;uid,
           byte[]&nbsp;buffer)</code>
<div class="block">ISO15693命令：用于锁定卡的AFI，锁定后AFI不可以更改。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_LockDSFID(byte, byte[], byte[])">API_LockDSFID</a></strong>(byte&nbsp;flags,
             byte[]&nbsp;uid,
             byte[]&nbsp;buffer)</code>
<div class="block">ISO15693命令：用于锁定卡的DSFID，锁定后DSFID不可以更改.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_PCDDec(byte, byte, byte[], byte[])">API_PCDDec</a></strong>(byte&nbsp;mode,
          byte&nbsp;SectNum,
          byte[]&nbsp;snr,
          byte[]&nbsp;value)</code>
<div class="block">ISO14443A命令：对卡的指定扇区进行减值操作。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_PCDInc(byte, byte, byte[], byte[])">API_PCDInc</a></strong>(byte&nbsp;mode,
          byte&nbsp;SectNum,
          byte[]&nbsp;snr,
          byte[]&nbsp;value)</code>
<div class="block">ISO14443A命令：对卡的指定扇区进行加值操作。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_PCDInitVal(byte, byte, byte[], byte[])">API_PCDInitVal</a></strong>(byte&nbsp;mode,
              byte&nbsp;SectNum,
              byte[]&nbsp;snr,
              byte[]&nbsp;value)</code>
<div class="block">ISO14443A命令：初始化卡.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_PCDRead(byte, byte, byte, byte[], byte[])">API_PCDRead</a></strong>(byte&nbsp;mode,
           byte&nbsp;blk_add,
           byte&nbsp;num_blk,
           byte[]&nbsp;snr,
           byte[]&nbsp;buffer)</code>
<div class="block">ISO14443A命令：在指定位置读取指定长度的数据.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_PCDWrite(byte, byte, byte, byte[], byte[])">API_PCDWrite</a></strong>(byte&nbsp;mode,
            byte&nbsp;blk_add,
            byte&nbsp;num_blk,
            byte[]&nbsp;snr,
            byte[]&nbsp;buffer)</code>
<div class="block">ISO14443A命令：在指定位置写入数据.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_ResetToReady(byte, byte[], byte[])">API_ResetToReady</a></strong>(byte&nbsp;flags,
                byte[]&nbsp;uid,
                byte[]&nbsp;buffer)</code>
<div class="block">ISO15693命令：操作成功后，卡回到Ready状态。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_SetSerNum(byte[], byte[])">API_SetSerNum</a></strong>(byte[]&nbsp;newValue,
             byte[]&nbsp;buffer)</code>
<div class="block">系统命令：设置 8个字节的产品序列号。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_WriteAFI(byte, byte, byte[], byte[])">API_WriteAFI</a></strong>(byte&nbsp;flags,
            byte&nbsp;afi,
            byte[]&nbsp;uid,
            byte[]&nbsp;buffer)</code>
<div class="block">ISO15693命令：对卡进行写AFI操作。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#API_WriteDSFID(byte, byte, byte[], byte[])">API_WriteDSFID</a></strong>(byte&nbsp;flags,
              byte&nbsp;DSFID,
              byte[]&nbsp;uid,
              byte[]&nbsp;buffer)</code>
<div class="block">ISO15693命令：对卡的进行写DSFID操作.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#GET_SNR(byte, byte, byte[], byte[])">GET_SNR</a></strong>(byte&nbsp;mode,
       byte&nbsp;API_halt,
       byte[]&nbsp;snr,
       byte[]&nbsp;value)</code>
<div class="block">ISO14443A命令：返回1个字节的单卡或多卡标识，4个字节的卡号。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#GetVersionNum(byte[])">GetVersionNum</a></strong>(byte[]&nbsp;VersionNum)</code>
<div class="block">系统命令：读取读写器的版本号.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#MF_Anticoll(byte[], byte[])">MF_Anticoll</a></strong>(byte[]&nbsp;snr,
           byte[]&nbsp;status)</code>
<div class="block">ISO14443A命令：检测卡片数量，单卡或多卡，并返回4个字节的卡号。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#MF_Halt()">MF_Halt</a></strong>()</code>
<div class="block">ISO14443A命令：选择卡，使卡进入被中断的状态.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#MF_Request(byte, byte[])">MF_Request</a></strong>(byte&nbsp;inf_mode,
          byte[]&nbsp;buffer)</code>
<div class="block">ISO14443A命令：发送ISO14443 A 寻卡指令。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#MF_Restore(byte, int, byte[])">MF_Restore</a></strong>(byte&nbsp;mode,
          int&nbsp;cardlength,
          byte[]&nbsp;carddata)</code>
<div class="block">ISO14443A命令：按照选择的模式，进行数据的发送.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#MF_Select(byte[])">MF_Select</a></strong>(byte[]&nbsp;snr)</code>
<div class="block">ISO14443A命令：使卡进入被选择的状态.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#ReadUserInfo(int, int, byte[])">ReadUserInfo</a></strong>(int&nbsp;num_blk,
            int&nbsp;num_length,
            byte[]&nbsp;user_info)</code>
<div class="block">系统命令：读取读卡器中提供4个块（每个块不能大于120个字节）的数据。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#Request_AB(byte[])">Request_AB</a></strong>(byte[]&nbsp;buffer)</code>
<div class="block">ISO14443B命令：该命令执行几集成了ISO14443B中的，REQUEST和ATTRIB命令，通过一个命令使卡复位。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#RequestType_B(byte[])">RequestType_B</a></strong>(byte[]&nbsp;buffer)</code>
<div class="block">ISO14443B命令：该命令执行ISO14443B中的REQB命令，获取卡片的PUPI代码。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#SelectType_B(byte[])">SelectType_B</a></strong>(byte[]&nbsp;SerialNum)</code>
<div class="block">ISO14443B命令：该命令执行ISO14443B中的ATTRIB命令，给已知PUPI的卡片分配一个识别号CID.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#UL_HLRead(byte, byte, byte[], byte[])">UL_HLRead</a></strong>(byte&nbsp;mode,
         byte&nbsp;blk_add,
         byte[]&nbsp;snr,
         byte[]&nbsp;buffer)</code>
<div class="block">Ultralight命令：发送Ultralight读卡命令。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#UL_HLWrite(byte, byte, byte[], byte[])">UL_HLWrite</a></strong>(byte&nbsp;mode,
          byte&nbsp;blk_add,
          byte[]&nbsp;snr,
          byte[]&nbsp;buffer)</code>
<div class="block">Ultralight命令：发送Ultralight写卡命令。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#UL_Request(byte, byte[])">UL_Request</a></strong>(byte&nbsp;mode,
          byte[]&nbsp;snr)</code>
<div class="block">Ultralight命令：发送Ultralight寻卡指令。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../com/syc/function/Function.html#WriteUserInfo(int, int, byte[])">WriteUserInfo</a></strong>(int&nbsp;num_blk,
             int&nbsp;num_length,
             byte[]&nbsp;user_info)</code>
<div class="block">系统命令：读卡器提供4个块（每个块不能大于120个字节），共480个字节空间的用户数据区。</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>从类继承的方法&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>构造器详细资料</h3>
<a name="Function()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Function</h4>
<pre>public&nbsp;Function()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>方法详细资料</h3>
<a name="API_SetSerNum(byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_SetSerNum</h4>
<pre>public static&nbsp;int&nbsp;API_SetSerNum(byte[]&nbsp;newValue,
                byte[]&nbsp;buffer)</pre>
<div class="block">系统命令：设置 8个字节的产品序列号。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>newValue</code> - 8个字节的读写器序列号.</dd><dd><code>buffer</code> - 用来返回接收到的数据.</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 设置成功：<br/>
 buffer=0x80<br/>
 设置失败：<br/>
 则buffer为底层（读卡器单片机）上传的错误代码。</dd></dl>
</li>
</ul>
<a name="API_GetSerNum(byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_GetSerNum</h4>
<pre>public static&nbsp;int&nbsp;API_GetSerNum(byte[]&nbsp;buffer)</pre>
<div class="block">系统命令：读取由厂家预设的1个字节的读卡器地址和8个字节序列号。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>buffer</code> - 用来返回接收到的数据。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 buffer[0] 读写器地址。<br/>
 buffer[1...8] 8个字节的读写器序列号。</dd></dl>
</li>
</ul>
<a name="WriteUserInfo(int, int, byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>WriteUserInfo</h4>
<pre>public static&nbsp;int&nbsp;WriteUserInfo(int&nbsp;num_blk,
                int&nbsp;num_length,
                byte[]&nbsp;user_info)</pre>
<div class="block">系统命令：读卡器提供4个块（每个块不能大于120个字节），共480个字节空间的用户数据区。用户可以根据需要，储存相应的用户信息到读写器中。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>num_blk</code> - 区域号。</dd><dd><code>num_length</code> - 数据长度。</dd><dd><code>user_info</code> - 用户数据。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.</dd></dl>
</li>
</ul>
<a name="ReadUserInfo(int, int, byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ReadUserInfo</h4>
<pre>public static&nbsp;int&nbsp;ReadUserInfo(int&nbsp;num_blk,
               int&nbsp;num_length,
               byte[]&nbsp;user_info)</pre>
<div class="block">系统命令：读取读卡器中提供4个块（每个块不能大于120个字节）的数据。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>num_blk</code> - 区域号。</dd><dd><code>num_length</code> - 读取的数据长度。</dd><dd><code>user_info</code> - 待读入的用户数据 。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.</dd></dl>
</li>
</ul>
<a name="GetVersionNum(byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GetVersionNum</h4>
<pre>public static&nbsp;int&nbsp;GetVersionNum(byte[]&nbsp;VersionNum)</pre>
<div class="block">系统命令：读取读写器的版本号.</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>VersionNum</code> - 待读入的版本号。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.</dd></dl>
</li>
</ul>
<a name="API_ControlLED(byte, byte, byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_ControlLED</h4>
<pre>public static&nbsp;int&nbsp;API_ControlLED(byte&nbsp;freq,
                 byte&nbsp;duration,
                 byte[]&nbsp;buffer)</pre>
<div class="block">系统命令：设置灯的工作状态，包括，灯亮的周期以及循环的次数。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>freq</code> - 周期数。</dd><dd><code>duration</code> - 次数。</dd><dd><code>buffer</code> - 待返回的参数。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作失败，  则buffer[0]为 错误代码。<br/>
 操作成功，  则buffer[0]为成功标志 ，即为0x80。</dd></dl>
</li>
</ul>
<a name="API_ControlBuzzer(byte, byte, byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_ControlBuzzer</h4>
<pre>public static&nbsp;int&nbsp;API_ControlBuzzer(byte&nbsp;freq,
                    byte&nbsp;duration,
                    byte[]&nbsp;buffer)</pre>
<div class="block">系统命令：设置蜂鸣器的工作状态，包括，蜂鸣器的工作周期以及循环的次数。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>freq</code> - 周期数。</dd><dd><code>duration</code> - 次数。</dd><dd><code>buffer</code> - 待返回的参数。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作失败，  则buffer[0]为 错误代码。<br/>
 操作成功，  则buffer[0]为成功标志 ，即为0x80。</dd></dl>
</li>
</ul>
<a name="MF_Request(byte, byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MF_Request</h4>
<pre>public static&nbsp;int&nbsp;MF_Request(byte&nbsp;inf_mode,
             byte[]&nbsp;buffer)</pre>
<div class="block">ISO14443A命令：发送ISO14443 A 寻卡指令。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>inf_mode</code> - 寻卡模式。<br/>
 0x52CIdle模式（一次只对一张卡操作）。<br/>
 0x26CAll模式（一次可对多张卡操作）。</dd><dd><code>buffer</code> - </dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作失败，  则snr[0]为 错误代码。<br/>
 操作成功，  则buffer[0..1]返回2个字节的数据串。</dd></dl>
</li>
</ul>
<a name="MF_Anticoll(byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MF_Anticoll</h4>
<pre>public static&nbsp;int&nbsp;MF_Anticoll(byte[]&nbsp;snr,
              byte[]&nbsp;status)</pre>
<div class="block">ISO14443A命令：检测卡片数量，单卡或多卡，并返回4个字节的卡号。（如果有多张卡，就返回其中一张卡的卡号）。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>snr</code> - 返回4个字节的卡号。</dd><dd><code>status</code> - 返回卡片的数量。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功：<br/>
 status[0] 检测到的卡片的数量(0x00表示检测到单卡,0x01表示检测到多卡)。<br/>
 snr 4个字节的卡号（snr[0..3]）。 <br/>
 操作失败：<br/>
 snr[0] 错误代码。</dd></dl>
</li>
</ul>
<a name="MF_Select(byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MF_Select</h4>
<pre>public static&nbsp;int&nbsp;MF_Select(byte[]&nbsp;snr)</pre>
<div class="block">ISO14443A命令：使卡进入被选择的状态.</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>snr</code> - 传入4个字节卡号，并且返回4个字节的卡号.</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 snr 4个字节的卡号（snr[0..3]）</dd></dl>
</li>
</ul>
<a name="MF_Halt()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MF_Halt</h4>
<pre>public static&nbsp;int&nbsp;MF_Halt()</pre>
<div class="block">ISO14443A命令：选择卡，使卡进入被中断的状态.</div>
<dl><dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.</dd></dl>
</li>
</ul>
<a name="API_PCDRead(byte, byte, byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_PCDRead</h4>
<pre>public static&nbsp;int&nbsp;API_PCDRead(byte&nbsp;mode,
              byte&nbsp;blk_add,
              byte&nbsp;num_blk,
              byte[]&nbsp;snr,
              byte[]&nbsp;buffer)</pre>
<div class="block">ISO14443A命令：在指定位置读取指定长度的数据.</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>mode</code> - 读取模式<br/>
 Idle+KeyA mode=00<br/>
 Idle+KeyB mode=02<br/>
 All+KeyA mode=01<br/>
 All+KeyB mode=03<br/></dd><dd><code>blk_add</code> - 读取块地址.</dd><dd><code>num_blk</code> - 读取块数目.</dd><dd><code>snr</code> - 六个字节的密钥.</dd><dd><code>buffer</code> - 等待接受输出变量.</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功:<br/>
 snr 4个字节的卡号.<br/>
 buffer 读取到的数据(具体数量为：num_blk*16).<br/>
 操作失败:<br/>
 snr[0] 错误代码.</dd></dl>
</li>
</ul>
<a name="API_PCDWrite(byte, byte, byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_PCDWrite</h4>
<pre>public static&nbsp;int&nbsp;API_PCDWrite(byte&nbsp;mode,
               byte&nbsp;blk_add,
               byte&nbsp;num_blk,
               byte[]&nbsp;snr,
               byte[]&nbsp;buffer)</pre>
<div class="block">ISO14443A命令：在指定位置写入数据.</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>mode</code> - 读取模式<br/>
 Idle+KeyA mode=00<br/>
 Idle+KeyB mode=02<br/>
 All+KeyA mode=01<br/>
 All+KeyB mode=03<br/></dd><dd><code>blk_add</code> - 要写块地址.</dd><dd><code>num_blk</code> - 要写块数目.</dd><dd><code>snr</code> - 6字节密码.</dd><dd><code>buffer</code> - 待写入的数据.</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功:<br/>
 snr[0..3] 4个字节的卡号.<br/>
 操作失败:<br/>
 snr[0] 错误代码.</dd></dl>
</li>
</ul>
<a name="API_PCDInitVal(byte, byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_PCDInitVal</h4>
<pre>public static&nbsp;int&nbsp;API_PCDInitVal(byte&nbsp;mode,
                 byte&nbsp;SectNum,
                 byte[]&nbsp;snr,
                 byte[]&nbsp;value)</pre>
<div class="block">ISO14443A命令：初始化卡.</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>mode</code> - 读取模式<br/>
 Idle+KeyA mode=00<br/>
 Idle+KeyB mode=02<br/>
 All+KeyA mode=01<br/>
 All+KeyB mode=03<br/></dd><dd><code>SectNum</code> - 要初始化的扇区号00-0F.</dd><dd><code>snr</code> - 6字节密钥.</dd><dd><code>value</code> - 4 字节的要初始化的数据.</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功:<br/>
 snr[0..3] 4个字节的卡号.<br/>
 操作失败:<br/>
 snr[0] 错误代码.</dd></dl>
</li>
</ul>
<a name="API_PCDDec(byte, byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_PCDDec</h4>
<pre>public static&nbsp;int&nbsp;API_PCDDec(byte&nbsp;mode,
             byte&nbsp;SectNum,
             byte[]&nbsp;snr,
             byte[]&nbsp;value)</pre>
<div class="block">ISO14443A命令：对卡的指定扇区进行减值操作。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>mode</code> - 读取模式<br/>
 Idle+KeyA mode=00<br/>
 Idle+KeyB mode=02<br/>
 All+KeyA mode=01<br/>
 All+KeyB mode=03<br/></dd><dd><code>SectNum</code> - 要写值的扇区号00-0F.</dd><dd><code>snr</code> - 6字节密钥.</dd><dd><code>value</code> - 要减的值，4个字节长度.</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功:<br/>
 snr[0..3] 4个字节的卡号.<br/>
 value[0..3] 4个字节操作后的数据串.<br/>
 操作失败:<br/>
 snr[0] 错误代码.</dd></dl>
</li>
</ul>
<a name="API_PCDInc(byte, byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_PCDInc</h4>
<pre>public static&nbsp;int&nbsp;API_PCDInc(byte&nbsp;mode,
             byte&nbsp;SectNum,
             byte[]&nbsp;snr,
             byte[]&nbsp;value)</pre>
<div class="block">ISO14443A命令：对卡的指定扇区进行加值操作。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>mode</code> - 读取模式<br/>
 Idle+KeyA mode=00<br/>
 Idle+KeyB mode=02<br/>
 All+KeyA mode=01<br/>
 All+KeyB mode=03<br/></dd><dd><code>SectNum</code> - 要加值的扇区号00-0F.</dd><dd><code>snr</code> - 6字节密钥.</dd><dd><code>value</code> - 要加的值，4个字节长度.</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功:<br/>
 snr[0..3] 4个字节的卡号.<br/>
 value[0..3] 4个字节操作后的数据串.<br/>
 操作失败:<br/>
 snr[0] 错误代码.</dd></dl>
</li>
</ul>
<a name="GET_SNR(byte, byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GET_SNR</h4>
<pre>public static&nbsp;int&nbsp;GET_SNR(byte&nbsp;mode,
          byte&nbsp;API_halt,
          byte[]&nbsp;snr,
          byte[]&nbsp;value)</pre>
<div class="block">ISO14443A命令：返回1个字节的单卡或多卡标识，4个字节的卡号。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>mode</code> - 模式控制.<br/>
 0x26CIdle模式（一次只对一张卡操作）.<br/>
 0x52CAll模式（一次可对多张卡操作).</dd><dd><code>API_halt</code> - </dd><dd><code>snr</code> - </dd><dd><code>value</code> - </dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功:<br/>
 snr[0] 1个字节的单卡或多卡标识.<br/>
 value[0..3] 返回的4个字节的卡号.<br/>
 操作失败:<br/>
 snr[0] 错误代码.</dd></dl>
</li>
</ul>
<a name="MF_Restore(byte, int, byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MF_Restore</h4>
<pre>public static&nbsp;int&nbsp;MF_Restore(byte&nbsp;mode,
             int&nbsp;cardlength,
             byte[]&nbsp;carddata)</pre>
<div class="block">ISO14443A命令：按照选择的模式，进行数据的发送.</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>mode</code> - 模式控制.<br/>
 0x00―不需要进行CRC校验.<br/>
 0x01―需要进行CRC校验.</dd><dd><code>cardlength</code> - </dd><dd><code>carddata</code> - </dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功：<br/>
 carddata[0..N] 接收返回数据。<br/>
 操作失败：<br/>
 carddata[0] 错误代码.</dd></dl>
</li>
</ul>
<a name="RequestType_B(byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RequestType_B</h4>
<pre>public static&nbsp;int&nbsp;RequestType_B(byte[]&nbsp;buffer)</pre>
<div class="block">ISO14443B命令：该命令执行ISO14443B中的REQB命令，获取卡片的PUPI代码。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>buffer</code> - 卡片复位后的数据串 （ATQB）。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功：<br/>
 buffer 卡片复位后的数据串（ATQB）.<br/>
 buffer[0] 卡片复位数据的长度.<br/>
 buffer[1..N] 操作后的数据串（ATQB）.<br/>
 操作失败：<br/>
 buffer[0] 错误代码.</dd></dl>
</li>
</ul>
<a name="AntiType_B(byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>AntiType_B</h4>
<pre>public static&nbsp;int&nbsp;AntiType_B(byte[]&nbsp;buffer)</pre>
<div class="block">ISO14443B命令：该命令执行ISO14443B中的AnticollB命令.</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>buffer</code> - 卡片返回的数据串（ATQB）.</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 如果操作成功：<br/>
 buffer[0..N] 卡片返回的数据串（ATQB）.<br/>
 如果操作失败：<br/>
 buffer[0] 错误代码.</dd></dl>
</li>
</ul>
<a name="SelectType_B(byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SelectType_B</h4>
<pre>public static&nbsp;int&nbsp;SelectType_B(byte[]&nbsp;SerialNum)</pre>
<div class="block">ISO14443B命令：该命令执行ISO14443B中的ATTRIB命令，给已知PUPI的卡片分配一个识别号CID.</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>SerialNum</code> - 卡的序列号.</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.</dd></dl>
</li>
</ul>
<a name="Request_AB(byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Request_AB</h4>
<pre>public static&nbsp;int&nbsp;Request_AB(byte[]&nbsp;buffer)</pre>
<div class="block">ISO14443B命令：该命令执行几集成了ISO14443B中的，REQUEST和ATTRIB命令，通过一个命令使卡复位。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>buffer</code> - 返回操作后的卡的序列号4个字节.</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 如果操作成功：<br/>
 buffer[0..3] 返回操作后的卡的序列号4个字节.<br/>
 如果操作失败：<br/>
 buffer[0] 错误代码.</dd></dl>
</li>
</ul>
<a name="API_ISO14443TypeBTransCOSCmd(byte[], int, byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_ISO14443TypeBTransCOSCmd</h4>
<pre>public static&nbsp;int&nbsp;API_ISO14443TypeBTransCOSCmd(byte[]&nbsp;cmd,
                               int&nbsp;cmdSize,
                               byte[]&nbsp;buffer)</pre>
<div class="block">ISO14443B命令：ISO14443传送命令，可以通过此命令向卡发任意有效的命令，数据.</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>cmd</code> - 待发送的数据.</dd><dd><code>cmdSize</code> - 数据长度.</dd><dd><code>buffer</code> - 回收的数据.</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功，则buffer[0..N] 为从卡返回的数据.<br/>
 操作失败，则buffer[0] 为错误代码.</dd></dl>
</li>
</ul>
<a name="API_ISO15693_Inventory(byte, byte, byte[], byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_ISO15693_Inventory</h4>
<pre>public static&nbsp;int&nbsp;API_ISO15693_Inventory(byte&nbsp;flag,
                         byte&nbsp;afi,
                         byte[]&nbsp;pData,
                         byte[]&nbsp;nrOfCard,
                         byte[]&nbsp;pBuffer)</pre>
<div class="block">ISO15693命令：此命令通过防冲突用于得到读卡区域内所有卡片的序列号（能得到的卡片数量与模块天线的输出功率有关，一般能对2~6卡进行防冲突）.</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>flag</code> - 标识字节1个字节.</dd><dd><code>afi</code> - AFI就是数据长度.</dd><dd><code>pData</code> - 发送的数据.</dd><dd><code>nrOfCard</code> - 返回的卡的数量.</dd><dd><code>pBuffer</code> - 返回的数据（包括FLAG和DSFID和8[]n个字节的卡号）.</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功:<br/>
 nrOfCard 返回的卡的数量（一个字节）.<br/>
 pBuffer 返回的数据（包括FLAG和DSFID和8*n个字节的卡号）.<br/>
 操作失败:<br/>
 nrOfCard 错误代码.</dd></dl>
</li>
</ul>
<a name="API_ISO15693Read(byte, byte, byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_ISO15693Read</h4>
<pre>public static&nbsp;int&nbsp;API_ISO15693Read(byte&nbsp;flags,
                   byte&nbsp;blk_add,
                   byte&nbsp;num_blk,
                   byte[]&nbsp;uid,
                   byte[]&nbsp;buffer)</pre>
<div class="block">ISO15693命令：用来读取1个或多个扇区的值，如果要读每个块的安全位，将FLAGS中Option_flag置为1，即FLAG = 0X42，每个扇区将返回5个字节，包括1个表示安全状态字节和4个字节的块内容，这时候每次最多能读12个块。如果FLAG = 02，将只返回4字节的块内容，这时候每次最多能读63个块。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>flags</code> - 标志位。<br/>
 0x02  不带uid。<br/>
 0x22    带uid。<br/>
 0x42  不带uid但是要读安全位。</dd><dd><code>blk_add</code> - 要读的起始块号。</dd><dd><code>num_blk</code> - 块的数量。</dd><dd><code>uid</code> - UID信息。</dd><dd><code>buffer</code> - 返回值。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功：<br/>
 buffer[0] 返回的flag。<br/>
 buffer[1..N] Data。<br/>
 操作失败：<br/>
 buffer[0]为错误代码。</dd></dl>
</li>
</ul>
<a name="API_ISO15693Write(byte, byte, byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_ISO15693Write</h4>
<pre>public static&nbsp;int&nbsp;API_ISO15693Write(byte&nbsp;flags,
                    byte&nbsp;blk_add,
                    byte&nbsp;num_blk,
                    byte[]&nbsp;uid,
                    byte[]&nbsp;data)</pre>
<div class="block">ISO15693命令：对一个块进行写操作（每次只能写一个块）。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>flags</code> - 标志位。<br/>
 0x02  不带uid。<br/>
 0x22    带uid。<br/>
 0x42  不带uid但是要读安全位。</dd><dd><code>blk_add</code> - 要写的起始块号。</dd><dd><code>num_blk</code> - 写的块的数量。</dd><dd><code>uid</code> - UID信息。</dd><dd><code>data</code> - 返回值。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作失败，则data[0]为错误代码</dd></dl>
</li>
</ul>
<a name="API_ISO15693Lock(byte, byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_ISO15693Lock</h4>
<pre>public static&nbsp;int&nbsp;API_ISO15693Lock(byte&nbsp;flags,
                   byte&nbsp;num_blk,
                   byte[]&nbsp;uid,
                   byte[]&nbsp;buffer)</pre>
<div class="block">ISO15693命令：用于锁定块内容。注意：此过程不可逆（不能解锁）块锁定后内容不能在修改。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>flags</code> - 标志位。<br/>
 0x02  不带uid。<br/>
 0x22    带uid。<br/>
 0x42  不带uid但是要读安全位。</dd><dd><code>num_blk</code> - 要锁的块号。</dd><dd><code>uid</code> - UID信息。</dd><dd><code>buffer</code> - 返回值。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功，则buffer[0]值为0x80。 <br/>
 操作失败，则buffer[0]为错误代码。</dd></dl>
</li>
</ul>
<a name="API_ISO15693StayQuiet(byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_ISO15693StayQuiet</h4>
<pre>public static&nbsp;int&nbsp;API_ISO15693StayQuiet(byte&nbsp;flags,
                        byte[]&nbsp;uid,
                        byte[]&nbsp;buffer)</pre>
<div class="block">ISO15693命令：此命令用于将卡置于静止的状态, 必须用地址模式，如果发送的数据与被操作的卡的序列号相同，操作成功后，卡将进入静止状态，否则状态不变。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>flags</code> - 标志位。<br/>
 0x02  不带uid。<br/>
 0x22    带uid。<br/>
 0x42  不带uid但是要读安全位。</dd><dd><code>uid</code> - UID信息。</dd><dd><code>buffer</code> - 返回值。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功，则buffer[0]值为0x80。 <br/>
 操作失败，则buffer[0]为错误代码。</dd></dl>
</li>
</ul>
<a name="API_ISO15693Select(byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_ISO15693Select</h4>
<pre>public static&nbsp;int&nbsp;API_ISO15693Select(byte&nbsp;flags,
                     byte[]&nbsp;uid,
                     byte[]&nbsp;buffer)</pre>
<div class="block">ISO15693命令：此命令必须用地址模式，如果发送的数据与被操作的卡的序列号相同，操作成功后，卡将进入被选择状态，否则状态不变。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>flags</code> - 标志位。<br/>
 0x02  不带uid。<br/>
 0x22    带uid。<br/>
 0x42  不带uid但是要读安全位。</dd><dd><code>uid</code> - UID信息。</dd><dd><code>buffer</code> - 返回值。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功，则buffer[0]值为0x80。 <br/>
 操作失败，则buffer[0]为错误代码。</dd></dl>
</li>
</ul>
<a name="API_ResetToReady(byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_ResetToReady</h4>
<pre>public static&nbsp;int&nbsp;API_ResetToReady(byte&nbsp;flags,
                   byte[]&nbsp;uid,
                   byte[]&nbsp;buffer)</pre>
<div class="block">ISO15693命令：操作成功后，卡回到Ready状态。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>flags</code> - 标志位。<br/>
 0x02  不带uid。<br/>
 0x22    带uid。<br/>
 0x42  不带uid但是要读安全位。</dd><dd><code>uid</code> - UID信息。</dd><dd><code>buffer</code> - 返回值。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功，则buffer[0]值为0x80。 <br/>
 操作失败，则buffer[0]为错误代码</dd></dl>
</li>
</ul>
<a name="API_WriteAFI(byte, byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_WriteAFI</h4>
<pre>public static&nbsp;int&nbsp;API_WriteAFI(byte&nbsp;flags,
               byte&nbsp;afi,
               byte[]&nbsp;uid,
               byte[]&nbsp;buffer)</pre>
<div class="block">ISO15693命令：对卡进行写AFI操作。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>flags</code> - 标志位。<br/>
 0x02  不带uid。<br/>
 0x22    带uid。<br/>
 0x42  不带uid但是要读安全位。</dd><dd><code>afi</code> - 待写的AFI.</dd><dd><code>uid</code> - UID信息。</dd><dd><code>buffer</code> - 返回值。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功，则buffer[0]值为0x80。 <br/>
 操作失败，则buffer[0]为错误代码</dd></dl>
</li>
</ul>
<a name="API_LockAFI(byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_LockAFI</h4>
<pre>public static&nbsp;int&nbsp;API_LockAFI(byte&nbsp;flags,
              byte[]&nbsp;uid,
              byte[]&nbsp;buffer)</pre>
<div class="block">ISO15693命令：用于锁定卡的AFI，锁定后AFI不可以更改。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>flags</code> - 标志位。<br/>
 0x02  不带uid。<br/>
 0x22    带uid。<br/>
 0x42  不带uid但是要读安全位。</dd><dd><code>uid</code> - UID信息。</dd><dd><code>buffer</code> - 返回值。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功，则buffer[0]值为0x80。 <br/>
 操作失败，则buffer[0]为错误代码</dd></dl>
</li>
</ul>
<a name="API_WriteDSFID(byte, byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_WriteDSFID</h4>
<pre>public static&nbsp;int&nbsp;API_WriteDSFID(byte&nbsp;flags,
                 byte&nbsp;DSFID,
                 byte[]&nbsp;uid,
                 byte[]&nbsp;buffer)</pre>
<div class="block">ISO15693命令：对卡的进行写DSFID操作.</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>flags</code> - 标志位。<br/>
 0x02  不带uid。<br/>
 0x22    带uid。<br/>
 0x42  不带uid但是要读安全位。</dd><dd><code>DSFID</code> - 要写的DSFID字节，长度为1个字节.</dd><dd><code>uid</code> - UID信息。</dd><dd><code>buffer</code> - 返回值。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功，则buffer[0]值为0x80。 <br/>
 操作失败，则buffer[0]为错误代码</dd></dl>
</li>
</ul>
<a name="API_LockDSFID(byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_LockDSFID</h4>
<pre>public static&nbsp;int&nbsp;API_LockDSFID(byte&nbsp;flags,
                byte[]&nbsp;uid,
                byte[]&nbsp;buffer)</pre>
<div class="block">ISO15693命令：用于锁定卡的DSFID，锁定后DSFID不可以更改.</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>flags</code> - 标志位。<br/>
 0x02  不带uid。<br/>
 0x22    带uid。<br/>
 0x42  不带uid但是要读安全位。</dd><dd><code>uid</code> - UID信息。</dd><dd><code>buffer</code> - 返回值。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功，则buffer[0]值为0x80。 <br/>
 操作失败，则buffer[0]为错误代码</dd></dl>
</li>
</ul>
<a name="API_ISO15693_GetSysInfo(byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_ISO15693_GetSysInfo</h4>
<pre>public static&nbsp;int&nbsp;API_ISO15693_GetSysInfo(byte&nbsp;flags,
                          byte[]&nbsp;uid,
                          byte[]&nbsp;buffer)</pre>
<div class="block">ISO15693命令：用于得到卡的详细信息，具体内容请参考，ISO15693协议资料。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>flags</code> - 标志位。<br/>
 0x02  不带uid。<br/>
 0x22    带uid。<br/>
 0x42  不带uid但是要读安全位。</dd><dd><code>uid</code> - UID信息。</dd><dd><code>buffer</code> - 返回值.</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功：<br/>
 Buffer [0]:    Flags<br/>
 Buffer [1]:    INFO Flags<br/>
 Buffer [2..9]: UID<br/>
 Buffer [10]:   DSFID<br/>
 Buffer [11]:   AFI<br/>
 Buffer [12..N]: Other fields<br/>
 操作失败，则Buffer[0] 返回 为错误代码。</dd></dl>
</li>
</ul>
<a name="API_ISO15693_GetMulSecurity(byte, byte, byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_ISO15693_GetMulSecurity</h4>
<pre>public static&nbsp;int&nbsp;API_ISO15693_GetMulSecurity(byte&nbsp;flags,
                              byte&nbsp;blkAddr,
                              byte&nbsp;blkNum,
                              byte[]&nbsp;uid,
                              byte[]&nbsp;pBuffer)</pre>
<div class="block">ISO15693命令：用于获取卡的各个块的安全状态位的数据</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>flag</code> - 标志位。<br/>
 0x02  不带uid。<br/>
 0x22    带uid。<br/>
 0x42  不带uid但是要读安全位。</dd><dd><code>blkAddr</code> - 要读的起始块号。</dd><dd><code>blkNum</code> - 读的块的数量。</dd><dd><code>uid</code> - UID信息。</dd><dd><code>pBuffer</code> - 返回值。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功：<br/>
 pBuffer 返回的数据。<br/>
 pBuffer[0]  返回的flags。<br/>
 pBuffer [1..N]  Block security status (块的安全状态)。 <br/>
 操作失败，则pBuffer[0]为错误代码。</dd></dl>
</li>
</ul>
<a name="API_ISO15693TransCOSCmd(byte[], int, byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_ISO15693TransCOSCmd</h4>
<pre>public static&nbsp;int&nbsp;API_ISO15693TransCOSCmd(byte[]&nbsp;cmd,
                          int&nbsp;cmdSize,
                          byte[]&nbsp;buffer)</pre>
<div class="block">ISO15693命令：一个通用命令，用户可以通过此命令，对卡进行各种操作。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>cmd</code> - 需要发送的数据。</dd><dd><code>cmdSize</code> - 数据长度。</dd><dd><code>buffer</code> - 返回值。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功：<br/>
 buffer 返回的数据。<br/>
 buffer[0..N] 从卡返回的数据。<br/>
 操作失败，则buffer[0]为错误代码。</dd></dl>
</li>
</ul>
<a name="UL_HLRead(byte, byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>UL_HLRead</h4>
<pre>public static&nbsp;int&nbsp;UL_HLRead(byte&nbsp;mode,
            byte&nbsp;blk_add,
            byte[]&nbsp;snr,
            byte[]&nbsp;buffer)</pre>
<div class="block">Ultralight命令：发送Ultralight读卡命令。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>mode</code> - 寻卡模式 。<br/>
 0x00CIdle模式。<br/>
 0x01CAll模式。</dd><dd><code>blk_add</code> - 写卡扇区号。</dd><dd><code>snr</code> - 返回7个字节的卡号。</dd><dd><code>buffer</code> - 返回16个字节的卡数据。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 如果操作成功：<br/>
 snr 7个字节的卡号.<br/>
 buffer 16个字节的卡数据.<br/>
 如果操作失败：<br/>
 buffer[0] 错误代码。</dd></dl>
</li>
</ul>
<a name="UL_HLWrite(byte, byte, byte[], byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>UL_HLWrite</h4>
<pre>public static&nbsp;int&nbsp;UL_HLWrite(byte&nbsp;mode,
             byte&nbsp;blk_add,
             byte[]&nbsp;snr,
             byte[]&nbsp;buffer)</pre>
<div class="block">Ultralight命令：发送Ultralight写卡命令。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>mode</code> - 寻卡模式 。<br/>
 0x00CIdle模式。<br/>
 0x01CAll模式。</dd><dd><code>blk_add</code> - 写卡扇区号。</dd><dd><code>snr</code> - 返回7个字节的卡号。</dd><dd><code>buffer</code> - 四个字节的写入卡扇区的数据。</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 如果操作成功：<br/>
 snr 7个字节的卡号.<br/>
 buffer 16个字节的卡数据.<br/>
 如果操作失败：<br/>
 buffer[0] 错误代码。</dd></dl>
</li>
</ul>
<a name="UL_Request(byte, byte[])">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>UL_Request</h4>
<pre>public static&nbsp;int&nbsp;UL_Request(byte&nbsp;mode,
             byte[]&nbsp;snr)</pre>
<div class="block">Ultralight命令：发送Ultralight寻卡指令。</div>
<dl><dt><span class="strong">参数:</span></dt><dd><code>mode</code> - 寻卡模式 。<br/>
 0x00CIdle模式。<br/>
 0x01CAll模式。</dd><dd><code>snr</code> - 待返回的参数</dd>
<dt><span class="strong">返回:</span></dt><dd>0x00    设置成功.<br/>
 0x01   设置失败.<br/><br/>
 操作成功，  则snr [0..6]，返回7个字节的数据串。<br/>
 操作失败，  则snr [0] 为 错误代码。</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="跳过导航链接"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../com/syc/function/package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/Function.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../index-files/index-1.html">索引</a></li>
<li><a href="../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>上一个类</li>
<li>下一个类</li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?com/syc/function/Function.html" target="_top">框架</a></li>
<li><a href="Function.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li>嵌套&nbsp;|&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">方法</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
